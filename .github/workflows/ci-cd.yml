name: Node.js CI/CD

on:
  push:
    branches: [ "main", "ci/cd" ]
  pull_request:
    branches: [ "main", "dev" ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [20.x, 22.x, 24.x]

    steps:
    - name: Checkout repository
      uses: actions/checkout@v6.0.0

    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v6
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run tests
      run: npm test

  build-and-push-image:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/ci/cd') # 배포 작업은 main 또는 ci/cd 브랜치에 푸시될 때만 실행
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v6.0.0
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_IAM_ACCESS_KEY }}
        aws-secret-access-key: ${{ secrets.AWS_IAM_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-2

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and Push Docker image to Amazon ECR
      uses: docker/build-push-action@v6
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: |
          ${{ vars.REGISTRY }}/${{ vars.REPOSITORY }}:${{ github.sha }}
          ${{ vars.REGISTRY }}/${{ vars.REPOSITORY }}:latest
        cache-from: type=registry,ref=${{ vars.REGISTRY }}/${{ vars.REPOSITORY }}:buildcache # 빌드 캐시를 레지스트리에 저장
        cache-to: type=registry,ref=${{ vars.REGISTRY }}/${{ vars.REPOSITORY }}:buildcache,mode=max

  
  deploy:
    needs: build-and-push-image
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/ci/cd') # 배포 작업은 main 또는 ci/cd 브랜치에 푸시될 때만 실행

    env:
      REGISTRY: ${{ vars.REGISTRY }}
      REPOSITORY: ${{ vars.REPOSITORY }}
      AWS_EC2_INSTANCE_ID: ${{ secrets.AWS_EC2_INSTANCE_ID }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_IAM_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_IAM_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: Install Session Manager Plugin for AWS CLI
        run: |
          ARCH=$(uname -m | tr '[:upper:]' '[:lower:]')
          case "$ARCH" in
            x86_64|amd64)
              PKG_PATH="https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb"
              ;;
            arm64|aarch64)
              PKG_PATH="https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_arm64/session-manager-plugin.deb"
              ;;
            *)
              echo "Unsupported architecture: $ARCH" >&2
              exit 1
              ;;
          esac

          curl -fsSL "$PKG_PATH" -o session-manager-plugin.deb
          sudo DEBIAN_FRONTEND=noninteractive dpkg -i session-manager-plugin.deb


      - name: Check Docker Installation
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${AWS_EC2_INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["command -v docker"]' \
            --query 'Command.CommandId' \
            --output text)

          echo "⏳ Checking Docker installation..."
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "${AWS_EC2_INSTANCE_ID}"

          echo "=== STDOUT ==="
          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${AWS_EC2_INSTANCE_ID}" \
            --query 'StandardOutputContent' \
            --output text)

          echo "=== STDERR ==="
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${AWS_EC2_INSTANCE_ID}" \
            --query 'StandardErrorContent' \
            --output text

          if [ -z "$OUTPUT" ]; then
            echo "Error: Docker is not installed on the EC2 instance" >&2
            exit 1
          fi

          echo "✅ Docker is installed: $OUTPUT"

      - name: Deploy via SSM
        run: |
          echo "⏳ Preparing environment variables for deployment..."
          # 환경 변수 파일을 github actions runner에 저장
          aws ssm get-parameters-by-path \
            --path "/prod/${{ vars.REPOSITORY }}" \
            --recursive \
            --with-decryption \
            --region ${{ env.AWS_REGION }} \
            --output json | \
            jq -r '.Parameters[] | "\(.Name | split("/")[-1] | ascii_upcase)=\(.Value)"' > .env.prod
          
          # base64로 인코딩된 .env.prod 파일을 EC2 인스턴스로 전송
          BASE64_ENV=$(base64 -w 0 .env.prod)
          
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${AWS_EC2_INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="echo $BASE64_ENV | base64 -d > .env.prod" \
            --query 'Command.CommandId' \
            --output text)

          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "${AWS_EC2_INSTANCE_ID}" || true
          
          # 상태를 먼저 확인
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${AWS_EC2_INSTANCE_ID}" \
            --query 'Status' \
            --output text)
            
          echo "Command Status: $STATUS"
          
            # 표준 에러 확인
          ERROR=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${AWS_EC2_INSTANCE_ID}" \
            --query 'StandardErrorContent' \
            --output text)

          echo "=== STDERR ==="
          echo "$ERROR"

          # 상태가 Success가 아니면 실패 처리
          if [ "$STATUS" != "Success" ]; then
            echo "Error: Deployment failed with status: $STATUS" >&2
            echo "Error Details: $ERROR" >&2
            exit 1
          fi
          
          echo "✅ Environment variables prepared."

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${AWS_EC2_INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters '{"commands":[
              "docker rm -f community-fe || true",
              "aws ecr get-login-password --region ${{ vars.AWS_REGION }} | docker login --username AWS --password-stdin ${{ vars.REGISTRY }}",
              "docker pull ${{vars.REGISTRY}}/${{vars.REPOSITORY}}:latest",
              "docker run -d --name community-fe -p 3000:3000 --env-file .env.prod ${{vars.REGISTRY}}/${{vars.REPOSITORY}}:latest"
            ]}' \
            --query 'Command.CommandId' \
            --output text)

          echo "⏳ Deploying application with Command ID: $COMMAND_ID"

          # wait 명령어에 --no-fail 옵션 대신 || true를 사용하여 실패해도 계속 진행
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "${AWS_EC2_INSTANCE_ID}" || true

          # 상태를 먼저 확인
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${AWS_EC2_INSTANCE_ID}" \
            --query 'Status' \
            --output text)

          echo "Command Status: $STATUS"

          # 표준 출력 확인
          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${AWS_EC2_INSTANCE_ID}" \
            --query 'StandardOutputContent' \
            --output text)

          echo "=== STDOUT ==="
          echo "$OUTPUT"

          # 표준 에러 확인
          ERROR=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${AWS_EC2_INSTANCE_ID}" \
            --query 'StandardErrorContent' \
            --output text)

          echo "=== STDERR ==="
          echo "$ERROR"

          # 상태가 Success가 아니면 실패 처리
          if [ "$STATUS" != "Success" ]; then
            echo "Error: Deployment failed with status: $STATUS" >&2
            echo "Error Details: $ERROR" >&2
            exit 1
          fi

          echo "✅ Deployment completed successfully!"

      - name: Perform Health Check via SSM
        run: |
          MAX_ATTEMPTS=6
          RETRY_INTERVAL=5

          echo "⏳ Waiting for application to be ready..."

          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Health check attempt $i/$MAX_ATTEMPTS..."

            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "${AWS_EC2_INSTANCE_ID}" \
              --document-name "AWS-RunShellScript" \
              --parameters commands="curl -f http://localhost:3000/ || exit 1" \
              --query 'Command.CommandId' \
              --output text)

            echo "Health check Command ID: $COMMAND_ID"

            # wait 명령어에 || true를 사용하여 실패해도 계속 진행
            aws ssm wait command-executed \
              --command-id "$COMMAND_ID" \
              --instance-id "${AWS_EC2_INSTANCE_ID}" || true

            # 상태 확인
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${AWS_EC2_INSTANCE_ID}" \
              --query 'Status' \
              --output text)

            echo "Health check status: $STATUS"

            if [ "$STATUS" = "Success" ]; then
              OUTPUT=$(aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${AWS_EC2_INSTANCE_ID}" \
                --query 'StandardOutputContent' \
                --output text)
              echo "=== STDOUT ==="
              echo "$OUTPUT"
              echo "✅ Health check passed successfully!"
              exit 0
            fi

            # 실패 시 에러 로그 출력
            OUTPUT=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${AWS_EC2_INSTANCE_ID}" \
              --query 'StandardOutputContent' \
              --output text)
            ERROR=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${AWS_EC2_INSTANCE_ID}" \
              --query 'StandardErrorContent' \
              --output text)

            echo "=== STDOUT ==="
            echo "$OUTPUT"
            echo "=== STDERR ==="
            echo "$ERROR"

            if [ $i -lt $MAX_ATTEMPTS ]; then
              echo "Health check failed, retrying in ${RETRY_INTERVAL} seconds..."
              sleep $RETRY_INTERVAL
            fi
          done

          # 모든 재시도 실패 시 에러 출력
          echo "Error: Health check failed after $MAX_ATTEMPTS attempts" >&2
          echo "Last error details above" >&2
          exit 1
            